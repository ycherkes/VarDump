//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using VarDump.Async;
using VarDump.CodeDom.Common;
using VarDump.CodeDom.Compiler;
using VarDump.CodeDom.Resources;

namespace VarDump.CodeDom.CSharp
{
    using System.Threading.Tasks;
    internal sealed partial class CSharpCodeGenerator : ICodeGenerator
    {

        private async Task<string> QuoteSnippetStringCStyleAsync(string value)
        {
            var b = new StringBuilder(value.Length + 5);

            var indentObj = new Indentation(_output, Indent + 1);

            b.Append('\"');

            int i = 0;
            while (i < value.Length)
            {
                switch (value[i])
                {
                    case '\r':
                        b.Append("\\r");
                        break;
                    case '\t':
                        b.Append("\\t");
                        break;
                    case '\"':
                        b.Append("\\\"");
                        break;
                    case '\'':
                        b.Append("\\\'");
                        break;
                    case '\\':
                        b.Append("\\\\");
                        break;
                    case '\0':
                        b.Append("\\0");
                        break;
                    case '\n':
                        b.Append("\\n");
                        break;
                    case '\u2028':
                    case '\u2029':
                        await (AppendEscapedCharAsync(b, value[i])).ConfigureAwait(false);
                        break;

                    default:
                        b.Append(value[i]);
                        break;
                }

                if (i > 0 && i % MaxLineLength == 0)
                {
                    //
                    // If current character is a high surrogate and the following 
                    // character is a low surrogate, don't break them. 
                    // Otherwise when we write the string to a file, we might lose 
                    // the characters.
                    // 
                    if (char.IsHighSurrogate(value[i]) && (i < value.Length - 1) && char.IsLowSurrogate(value[i + 1]))
                    {
                        b.Append(value[++i]);
                    }

                    b.Append("\" +");
                    b.Append(Environment.NewLine);
                    b.Append(indentObj.IndentationString);
                    b.Append('\"');
                }
                ++i;
            }

            b.Append('\"');

            return b.ToString();
        }

        private Task<string> QuoteSnippetStringAsync(string value)
        {
            try
            {
                // If the string is short, use C style quoting (e.g "\r\n")
                // Also do it if it is too long to fit in one line
                // If the string contains '\0', verbatim style won't work.
                if (value.Length < 256 || value.Length > 1500 || (value.IndexOf('\0') != -1))
                    return QuoteSnippetStringCStyleAsync(value);

                // Otherwise, use 'verbatim' style quoting (e.g. @"foo")
                return Task.FromResult<string>(QuoteSnippetStringVerbatimStyle(value));
            }
            catch (Exception ex)
            {
                return TaskPolyfills.FromException<string>(ex);
            }
        }

        private Task ContinueOnNewLineAsync(string st) => Output.WriteLineAsync(st);

        private Task OutputIdentifierAsync(string ident) => Output.WriteAsync(CreateEscapedIdentifier(ident));

        private Task OutputTypeAsync(CodeTypeReference typeRef) => Output.WriteAsync(GetTypeOutput(typeRef));

        private async Task GenerateArrayCreateExpressionAsync(CodeArrayCreateExpression e)
        {
            await (Output.WriteAsync("new ")).ConfigureAwait(false);

            CodeExpressionCollection init = e.Initializers;
            if (init.Count > 0)
            {
                await (OutputTypeAsync(e.CreateType)).ConfigureAwait(false);
                await (Output.WriteLineAsync("")).ConfigureAwait(false);
                await (Output.WriteLineAsync("{")).ConfigureAwait(false);
                await (OutputExpressionListAsync(init, newlineBetweenItems: true)).ConfigureAwait(false);
                await (Output.WriteLineAsync()).ConfigureAwait(false);
                await (Output.WriteAsync("}")).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteAsync(GetBaseTypeOutput(e.CreateType))).ConfigureAwait(false);

                await (Output.WriteAsync('[')).ConfigureAwait(false);
                if (e.SizeExpression != null)
                {
                    await (GenerateExpressionAsync(e.SizeExpression)).ConfigureAwait(false);
                }
                else
                {
                    Output.Write(e.Size);
                }
                await (Output.WriteAsync(']')).ConfigureAwait(false);

                int nestedArrayDepth = e.CreateType.NestedArrayDepth;
                for (int i = 0; i < nestedArrayDepth - 1; i++)
                {
                    await (Output.WriteAsync("[]")).ConfigureAwait(false);
                }
            }
        }

        private async Task GenerateArrayDimensionExpressionAsync(CodeArrayDimensionExpression e)
        {
            await (Output.WriteAsync("{")).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
            await (OutputExpressionListAsync(e.Initializers, newlineBetweenItems: true)).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
            await (Output.WriteAsync("}")).ConfigureAwait(false);
        }

        private async Task GenerateBinaryOperatorExpressionAsync(CodeBinaryOperatorExpression e)
        {
            bool indentedExpression = false;
            await (Output.WriteAsync('(')).ConfigureAwait(false);

            await (GenerateExpressionAsync(e.Left)).ConfigureAwait(false);
            await (Output.WriteAsync(' ')).ConfigureAwait(false);

            if (e.Left is CodeBinaryOperatorExpression || e.Right is CodeBinaryOperatorExpression)
            {
                // In case the line gets too long with nested binary operators, we need to output them on
                // different lines. However we want to indent them to maintain readability, but this needs
                // to be done only once;
                if (!_inNestedBinary)
                {
                    indentedExpression = true;
                    _inNestedBinary = true;
                    Indent += 3;
                }
                await (ContinueOnNewLineAsync("")).ConfigureAwait(false);
            }

            await (OutputOperatorAsync(e.Operator)).ConfigureAwait(false);

            await (Output.WriteAsync(' ')).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Right)).ConfigureAwait(false);

            await (Output.WriteAsync(')')).ConfigureAwait(false);
            if (indentedExpression)
            {
                Indent -= 3;
                _inNestedBinary = false;
            }
        }

        private async Task GenerateCastExpressionAsync(CodeCastExpression e)
        {
            if (e.SimpleParentheses)
            {
                await (Output.WriteAsync("(")).ConfigureAwait(false);
                await (OutputTypeAsync(e.TargetType)).ConfigureAwait(false);
                await (Output.WriteAsync(")")).ConfigureAwait(false);
                await (GenerateExpressionAsync(e.Expression)).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteAsync("((")).ConfigureAwait(false);
                await (OutputTypeAsync(e.TargetType)).ConfigureAwait(false);
                await (Output.WriteAsync(")(")).ConfigureAwait(false);
                await (GenerateExpressionAsync(e.Expression)).ConfigureAwait(false);
                await (Output.WriteAsync("))")).ConfigureAwait(false);
            }
        }

        private async Task GenerateCodeAssignExpressionAsync(CodeAssignExpression e)
        {
            await (GenerateExpressionAsync(e.Left)).ConfigureAwait(false);
            await (Output.WriteAsync(" = ")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Right)).ConfigureAwait(false);
        }

        private async Task GenerateDefaultValueExpressionAsync(CodeDefaultValueExpression e)
        {
            await (Output.WriteAsync("default(")).ConfigureAwait(false);
            await (OutputTypeAsync(e.Type)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        private async Task GenerateFieldReferenceExpressionAsync(CodeFieldReferenceExpression e)
        {
            if (e.TargetObject != null)
            {
                await (GenerateExpressionAsync(e.TargetObject)).ConfigureAwait(false);
                await (Output.WriteAsync('.')).ConfigureAwait(false);
            }
            await (OutputIdentifierAsync(e.FieldName)).ConfigureAwait(false);
        }

        private Task GenerateVariableReferenceExpressionAsync(CodeVariableReferenceExpression e) =>
            OutputIdentifierAsync(e.VariableName);

        private Task GenerateSnippetExpressionAsync(CodeSnippetExpression e)
        {
            return Output.WriteAsync(e.Value);
        }

        private async Task GenerateMethodInvokeExpressionAsync(CodeMethodInvokeExpression e)
        {
            await (GenerateMethodReferenceExpressionAsync(e.Method)).ConfigureAwait(false);
            await (Output.WriteAsync('(')).ConfigureAwait(false);
            await (OutputExpressionListAsync(e.Parameters)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        private async Task GenerateMethodReferenceExpressionAsync(CodeMethodReferenceExpression e)
        {
            if (e.TargetObject != null)
            {
                if (e.TargetObject is CodeBinaryOperatorExpression)
                {
                    await (Output.WriteAsync('(')).ConfigureAwait(false);
                    await (GenerateExpressionAsync(e.TargetObject)).ConfigureAwait(false);
                    await (Output.WriteAsync(')')).ConfigureAwait(false);
                }
                else
                {
                    await (GenerateExpressionAsync(e.TargetObject)).ConfigureAwait(false);
                }
                await (Output.WriteAsync('.')).ConfigureAwait(false);
            }
            await (OutputIdentifierAsync(e.MethodName)).ConfigureAwait(false);

            if (e.TypeArguments.Count > 0)
            {
                await (Output.WriteAsync(GetTypeArgumentsOutput(e.TypeArguments))).ConfigureAwait(false);
            }
        }

        private async Task GenerateStatementAsync(CodeStatement e)
        {
            if (e is CodeCommentStatement)
            {
                await (GenerateCommentStatementAsync((CodeCommentStatement)e)).ConfigureAwait(false);
            }
            else if (e is CodeConditionStatement)
            {
                await (GenerateConditionStatementAsync((CodeConditionStatement)e)).ConfigureAwait(false);
            }
            else if (e is CodeAssignStatement)
            {
                await (GenerateAssignStatementAsync((CodeAssignStatement)e)).ConfigureAwait(false);
            }
            else if (e is CodeExpressionStatement)
            {
                await (GenerateExpressionStatementAsync((CodeExpressionStatement)e)).ConfigureAwait(false);
            }
            else if (e is CodeSnippetStatement)
            {
                // Don't indent snippet statements, in order to preserve the column
                // information from the original code.  This improves the debugging
                // experience.
                int savedIndent = Indent;
                Indent = 0;

                await (GenerateSnippetStatementAsync((CodeSnippetStatement)e)).ConfigureAwait(false);

                // Restore the indent
                Indent = savedIndent;
            }
            else if (e is CodeVariableDeclarationStatement)
            {
                await (GenerateVariableDeclarationStatementAsync((CodeVariableDeclarationStatement)e)).ConfigureAwait(false);
            }
            else
            {
                throw new ArgumentException(SR.Format(SR.InvalidElementType, e.GetType().FullName), nameof(e));
            }
        }

        private Task GenerateStatementExpressionAsync(CodeStatementExpression e)
        {
            return GenerateStatementAsync(e.Statement);
        }

        private async Task GenerateStatementsAsync(CodeStatementCollection statements)
        {
            foreach (CodeStatement statement in statements)
            {
                await (((ICodeGenerator)this).GenerateCodeFromStatementAsync(statement, _output.InnerWriter, _options)).ConfigureAwait(false);
            }
        }

        private async Task GenerateObjectCreateAndInitializeExpressionAsync(CodeObjectCreateAndInitializeExpression e)
        {
            await (Output.WriteAsync("new ")).ConfigureAwait(false);
            await (OutputTypeAsync(e.CreateType)).ConfigureAwait(false);
            if (e.Parameters.Count > 0 || e.InitializeExpressions.Count == 0)
            {
                await (Output.WriteAsync('(')).ConfigureAwait(false);
                await (OutputExpressionListAsync(e.Parameters)).ConfigureAwait(false);
                await (Output.WriteAsync(')')).ConfigureAwait(false);
            }

            if (e.InitializeExpressions.Count > 0)
            {
                await (Output.WriteLineAsync()).ConfigureAwait(false);
                await (Output.WriteLineAsync('{')).ConfigureAwait(false);
                await (OutputExpressionListAsync(e.InitializeExpressions, newlineBetweenItems: true)).ConfigureAwait(false);
                await (Output.WriteLineAsync()).ConfigureAwait(false);
                await (Output.WriteAsync("}")).ConfigureAwait(false);
            }
        }

        private async Task GenerateValueTupleCreateExpressionAsync(CodeValueTupleCreateExpression e)
        {
            await (Output.WriteAsync('(')).ConfigureAwait(false);
            await (OutputExpressionListAsync(e.Parameters)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }
        private async Task GenerateObjectCreateExpressionAsync(CodeObjectCreateExpression e)
        {
            await (Output.WriteAsync("new ")).ConfigureAwait(false);
            await (OutputTypeAsync(e.CreateType)).ConfigureAwait(false);
            await (Output.WriteAsync('(')).ConfigureAwait(false);
            await (OutputExpressionListAsync(e.Parameters)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        private async Task GeneratePrimitiveExpressionAsync(CodePrimitiveExpression e)
        {
            if (e.Value is char)
            {
                await (GeneratePrimitiveCharAsync((char)e.Value)).ConfigureAwait(false);
            }
            else if (e.Value is sbyte)
            {
                // C# has no literal marker for types smaller than Int32                
                await (Output.WriteAsync(((sbyte)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
            }
            else if (e.Value is ushort)
            {
                // C# has no literal marker for types smaller than Int32, and you will
                // get a conversion error if you use "u" here.
                await (Output.WriteAsync(((ushort)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
            }
            else if (e.Value is uint)
            {
                await (Output.WriteAsync(((uint)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
                await (Output.WriteAsync('u')).ConfigureAwait(false);
            }
            else if (e.Value is ulong)
            {
                await (Output.WriteAsync(((ulong)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
                await (Output.WriteAsync("ul")).ConfigureAwait(false);
            }
            else
            {
                await (GeneratePrimitiveExpressionBaseAsync(e)).ConfigureAwait(false);
            }
        }

        private async Task GeneratePrimitiveExpressionBaseAsync(CodePrimitiveExpression e)
        {
            if (e.Value == null)
            {
                await (Output.WriteAsync(NullToken)).ConfigureAwait(false);
            }
            else if (e.Value is string)
            {
                await (Output.WriteAsync(await (QuoteSnippetStringAsync((string)e.Value)).ConfigureAwait(false))).ConfigureAwait(false);
            }
            else if (e.Value is char)
            {
                await (Output.WriteAsync("'" + e.Value + "'")).ConfigureAwait(false);
            }
            else if (e.Value is byte)
            {
                await (Output.WriteAsync(((byte)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
            }
            else if (e.Value is short)
            {
                await (Output.WriteAsync(((short)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
            }
            else if (e.Value is int)
            {
                await (Output.WriteAsync(((int)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
            }
            else if (e.Value is long)
            {
                await (Output.WriteAsync(((long)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
            }
            else if (e.Value is float)
            {
                await (GenerateSingleFloatValueAsync((float)e.Value)).ConfigureAwait(false);
            }
            else if (e.Value is double)
            {
                await (GenerateDoubleValueAsync((double)e.Value)).ConfigureAwait(false);
            }
            else if (e.Value is decimal)
            {
                await (GenerateDecimalValueAsync((decimal)e.Value)).ConfigureAwait(false);
            }
            else if (e.Value is bool)
            {
                if ((bool)e.Value)
                {
                    await (Output.WriteAsync("true")).ConfigureAwait(false);
                }
                else
                {
                    await (Output.WriteAsync("false")).ConfigureAwait(false);
                }
            }
            else
            {
                throw new ArgumentException(SR.Format(SR.InvalidPrimitiveType, e.Value.GetType().ToString()));
            }
        }

        private async Task GeneratePrimitiveCharAsync(char c)
        {
            await (Output.WriteAsync('\'')).ConfigureAwait(false);
            switch (c)
            {
                case '\r':
                    await (Output.WriteAsync("\\r")).ConfigureAwait(false);
                    break;
                case '\t':
                    await (Output.WriteAsync("\\t")).ConfigureAwait(false);
                    break;
                case '\"':
                    await (Output.WriteAsync("\\\"")).ConfigureAwait(false);
                    break;
                case '\'':
                    await (Output.WriteAsync("\\\'")).ConfigureAwait(false);
                    break;
                case '\\':
                    await (Output.WriteAsync("\\\\")).ConfigureAwait(false);
                    break;
                case '\0':
                    await (Output.WriteAsync("\\0")).ConfigureAwait(false);
                    break;
                case '\n':
                    await (Output.WriteAsync("\\n")).ConfigureAwait(false);
                    break;
                case '\u2028':
                case '\u2029':
                case '\u0084':
                case '\u0085':
                    await (AppendEscapedCharAsync(null, c)).ConfigureAwait(false);
                    break;

                default:
                    if (char.IsSurrogate(c))
                    {
                        await (AppendEscapedCharAsync(null, c)).ConfigureAwait(false);
                    }
                    else
                    {
                        await (Output.WriteAsync(c)).ConfigureAwait(false);
                    }
                    break;
            }
            await (Output.WriteAsync('\'')).ConfigureAwait(false);
        }

        private async Task AppendEscapedCharAsync(StringBuilder b, char value)
        {
            if (b == null)
            {
                await (Output.WriteAsync("\\u")).ConfigureAwait(false);
                await (Output.WriteAsync(((int)value).ToString("X4", CultureInfo.InvariantCulture))).ConfigureAwait(false);
            }
            else
            {
                b.Append("\\u");
                b.Append(((int)value).ToString("X4", CultureInfo.InvariantCulture));
            }
        }

        private async Task GenerateExpressionStatementAsync(CodeExpressionStatement e)
        {
            await (GenerateExpressionAsync(e.Expression)).ConfigureAwait(false);
            await (Output.WriteLineAsync(';')).ConfigureAwait(false);
        }

        private async Task GenerateCommentAsync(CodeComment e)
        {
            string commentLineStart = e.DocComment ? "///" : "//";
            await (Output.WriteAsync(commentLineStart)).ConfigureAwait(false);
            await (Output.WriteAsync(' ')).ConfigureAwait(false);

            string value = e.Text;
            for (int i = 0; i < value.Length; i++)
            {
                if (value[i] == '\u0000')
                {
                    continue;
                }

                await (Output.WriteAsync(value[i])).ConfigureAwait(false);

                if (value[i] == '\r')
                {
                    if (i < value.Length - 1 && value[i + 1] == '\n')
                    {
                        // if next char is '\n', skip it
                        await (Output.WriteAsync('\n')).ConfigureAwait(false);
                        i++;
                    }

                    await (_output.InternalOutputTabsAsync()).ConfigureAwait(false);
                    await (Output.WriteAsync(commentLineStart)).ConfigureAwait(false);
                }
                else if (value[i] == '\n')
                {
                    await (_output.InternalOutputTabsAsync()).ConfigureAwait(false);
                    await (Output.WriteAsync(commentLineStart)).ConfigureAwait(false);
                }
                else if (value[i] == '\u2028' || value[i] == '\u2029' || value[i] == '\u0085')
                {
                    await (Output.WriteAsync(commentLineStart)).ConfigureAwait(false);
                }
            }
            if (!e.NoNewLine)
            {
                await (Output.WriteLineAsync()).ConfigureAwait(false);
            }
        }

        private Task GenerateCommentStatementAsync(CodeCommentStatement e)
        {
            if (e.Comment == null)
            {
                throw new ArgumentException(SR.Format(SR.Argument_NullComment, nameof(e)), nameof(e));
            }
            return GenerateCommentAsync(e.Comment);
        }

        private async Task GenerateConditionStatementAsync(CodeConditionStatement e)
        {
            await (Output.WriteAsync("if (")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Condition)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
            await (OutputStartingBraceAsync()).ConfigureAwait(false);
            Indent++;
            await (GenerateStatementsAsync(e.TrueStatements)).ConfigureAwait(false);
            Indent--;

            CodeStatementCollection falseStatemetns = e.FalseStatements;
            if (falseStatemetns.Count > 0)
            {
                await (Output.WriteAsync('}')).ConfigureAwait(false);
                if (Options.ElseOnClosing)
                {
                    await (Output.WriteAsync(' ')).ConfigureAwait(false);
                }
                else
                {
                    await (Output.WriteLineAsync()).ConfigureAwait(false);
                }
                await (Output.WriteAsync("else")).ConfigureAwait(false);
                await (OutputStartingBraceAsync()).ConfigureAwait(false);
                Indent++;
                await (GenerateStatementsAsync(e.FalseStatements)).ConfigureAwait(false);
                Indent--;
            }
            await (Output.WriteLineAsync('}')).ConfigureAwait(false);
        }

        private async Task GenerateAssignStatementAsync(CodeAssignStatement e)
        {
            await (GenerateExpressionAsync(e.Left)).ConfigureAwait(false);
            await (Output.WriteAsync(" = ")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Right)).ConfigureAwait(false);
            await (Output.WriteLineAsync(';')).ConfigureAwait(false);
        }

        private Task GenerateSnippetStatementAsync(CodeSnippetStatement e)
        {
            return Output.WriteLineAsync(e.Value);
        }

        private async Task GenerateVariableDeclarationStatementAsync(CodeVariableDeclarationStatement e)
        {
            await (OutputTypeNamePairAsync(e.Type, e.Name)).ConfigureAwait(false);
            if (e.InitExpression != null)
            {
                await (Output.WriteAsync(" = ")).ConfigureAwait(false);
                await (GenerateExpressionAsync(e.InitExpression)).ConfigureAwait(false);
            }
            await (Output.WriteLineAsync(';')).ConfigureAwait(false);
        }

        private Task GenerateExpressionAsync(CodeExpression e)
        {
            try
            {
                if (e is CodeStatementExpression)
                {
                    return GenerateStatementExpressionAsync((CodeStatementExpression)e);
                }
                else if (e is CodeSeparatedExpressionCollection)
                {
                    return GenerateSeparatedExpressionCollectionAsync((CodeSeparatedExpressionCollection)e);
                }
                else if (e is CodeArrayCreateExpression)
                {
                    return GenerateArrayCreateExpressionAsync((CodeArrayCreateExpression)e);
                }
                else if (e is CodeArrayDimensionExpression)
                {
                    return GenerateArrayDimensionExpressionAsync((CodeArrayDimensionExpression)e);
                }
                else if (e is CodeFlagsBinaryOperatorExpression)
                {
                    return GenerateFlagsBinaryOperatorExpressionAsync((CodeFlagsBinaryOperatorExpression)e);
                }
                else if (e is CodeBinaryOperatorExpression)
                {
                    return GenerateBinaryOperatorExpressionAsync((CodeBinaryOperatorExpression)e);
                }
                else if (e is CodeCastExpression)
                {
                    return GenerateCastExpressionAsync((CodeCastExpression)e);
                }
                else if (e is CodeFieldReferenceExpression)
                {
                    return GenerateFieldReferenceExpressionAsync((CodeFieldReferenceExpression)e);
                }
                else if (e is CodeVariableReferenceExpression)
                {
                    return GenerateVariableReferenceExpressionAsync((CodeVariableReferenceExpression)e);
                }
                else if (e is CodeSnippetExpression)
                {
                    return GenerateSnippetExpressionAsync((CodeSnippetExpression)e);
                }
                else if (e is CodeMethodInvokeExpression)
                {
                    return GenerateMethodInvokeExpressionAsync((CodeMethodInvokeExpression)e);
                }
                else if (e is CodeMethodReferenceExpression)
                {
                    return GenerateMethodReferenceExpressionAsync((CodeMethodReferenceExpression)e);
                }
                else if (e is CodeObjectCreateAndInitializeExpression)
                {
                    return GenerateObjectCreateAndInitializeExpressionAsync((CodeObjectCreateAndInitializeExpression)e);
                }
                else if (e is CodeNamedArgumentExpression na)
                {
                    return GenerateNamedArgumentExpressionAsync(na);
                }
                else if (e is CodeValueTupleCreateExpression)
                {
                    return GenerateValueTupleCreateExpressionAsync((CodeValueTupleCreateExpression)e);
                }
                else if (e is CodeImplicitKeyValuePairCreateExpression)
                {
                    return GenerateCodeImplicitKeyValuePairCreateExpressionAsync((CodeImplicitKeyValuePairCreateExpression)e);
                }
                else if (e is CodeObjectCreateExpression)
                {
                    return GenerateObjectCreateExpressionAsync((CodeObjectCreateExpression)e);
                }
                else if (e is CodeLambdaExpression)
                {
                    return GenerateLambdaExpressionAsync((CodeLambdaExpression)e);
                }
                else if (e is CodePrimitiveExpression)
                {
                    return GeneratePrimitiveExpressionAsync((CodePrimitiveExpression)e);
                }
                else if (e is CodePropertyReferenceExpression)
                {
                    return GeneratePropertyReferenceExpressionAsync((CodePropertyReferenceExpression)e);
                }
                else if (e is CodeTypeReferenceExpression)
                {
                    return GenerateTypeReferenceExpressionAsync((CodeTypeReferenceExpression)e);
                }
                else if (e is CodeTypeOfExpression)
                {
                    return GenerateTypeOfExpressionAsync((CodeTypeOfExpression)e);
                }
                else if (e is CodeDefaultValueExpression)
                {
                    return GenerateDefaultValueExpressionAsync((CodeDefaultValueExpression)e);
                }
                else if (e is CodeAssignExpression)
                {
                    return GenerateCodeAssignExpressionAsync((CodeAssignExpression)e);
                }
                else
                {
                    if (e == null)
                    {
                        return TaskPolyfills.FromException(new ArgumentNullException(nameof(e)));
                    }

                    return TaskPolyfills.FromException(new ArgumentException(SR.Format(SR.InvalidElementType, e.GetType().FullName), nameof(e)));
                }
            }
            catch (Exception ex)
            {
                return TaskPolyfills.FromException(ex);
            }
        }

        private async Task GenerateNamedArgumentExpressionAsync(CodeNamedArgumentExpression na)
        {
            await (Output.WriteAsync(na.Name)).ConfigureAwait(false);
            await (Output.WriteAsync(": ")).ConfigureAwait(false);
            await (GenerateExpressionAsync(na.Value)).ConfigureAwait(false);
        }

        private async Task GenerateFlagsBinaryOperatorExpressionAsync(CodeFlagsBinaryOperatorExpression e)
        {
            if (e.Expressions.Count == 0) return;

            bool isFirst = true;

            foreach (CodeExpression expression in e.Expressions)
            {
                if (isFirst)
                {
                    await (GenerateExpressionAsync(e.Expressions[0])).ConfigureAwait(false);
                    isFirst = false;
                }
                else
                {
                    await (Output.WriteAsync(' ')).ConfigureAwait(false);
                    await (OutputOperatorAsync(e.Operator)).ConfigureAwait(false);
                    await (Output.WriteAsync(' ')).ConfigureAwait(false);
                    await (GenerateExpressionAsync(expression)).ConfigureAwait(false);
                }
            }
        }

        private async Task GenerateSeparatedExpressionCollectionAsync(CodeSeparatedExpressionCollection e)
        {
            var collectionLength = e.ExpressionCollection.Count;
            int current = 0;

            foreach (CodeExpression codeExpression in e.ExpressionCollection)
            {
                current++;
                await (GenerateExpressionAsync(codeExpression)).ConfigureAwait(false);
                if (current < collectionLength)
                {
                    await (Output.WriteAsync(e.Separator)).ConfigureAwait(false);
                }
            }
        }

        private async Task GenerateCodeImplicitKeyValuePairCreateExpressionAsync(CodeImplicitKeyValuePairCreateExpression e)
        {
            await (Output.WriteLineAsync('{')).ConfigureAwait(false);
            await (OutputExpressionListAsync(new CodeExpressionCollection(new[] { e.Key, e.Value }), true)).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
            await (Output.WriteAsync('}')).ConfigureAwait(false);
        }

        private async Task GenerateLambdaExpressionAsync(CodeLambdaExpression codeLambdaExpression)
        {
            if (codeLambdaExpression.Parameters.Count != 1)
            {
                await (Output.WriteAsync('(')).ConfigureAwait(false);
            }
            bool first = true;
            foreach (CodeExpression current in codeLambdaExpression.Parameters)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    await (Output.WriteAsync(", ")).ConfigureAwait(false);
                }
                await (GenerateExpressionAsync(current)).ConfigureAwait(false);
            }

            if (codeLambdaExpression.Parameters.Count != 1)
            {
                await (Output.WriteAsync(')')).ConfigureAwait(false);
            }
            await (Output.WriteAsync(" => ")).ConfigureAwait(false);
            await (GenerateExpressionAsync(codeLambdaExpression.LambdaExpression)).ConfigureAwait(false);
        }

        private async Task GenerateSingleFloatValueAsync(float s)
        {
            if (float.IsNaN(s))
            {
                await (Output.WriteAsync("float.NaN")).ConfigureAwait(false);
            }
            else if (float.IsNegativeInfinity(s))
            {
                await (Output.WriteAsync("float.NegativeInfinity")).ConfigureAwait(false);
            }
            else if (float.IsPositiveInfinity(s))
            {
                await (Output.WriteAsync("float.PositiveInfinity")).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteAsync(s.ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
                await (Output.WriteAsync('F')).ConfigureAwait(false);
            }
        }

        private async Task GenerateDoubleValueAsync(double d)
        {
            if (double.IsNaN(d))
            {
                await (Output.WriteAsync("double.NaN")).ConfigureAwait(false);
            }
            else if (double.IsNegativeInfinity(d))
            {
                await (Output.WriteAsync("double.NegativeInfinity")).ConfigureAwait(false);
            }
            else if (double.IsPositiveInfinity(d))
            {
                await (Output.WriteAsync("double.PositiveInfinity")).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteAsync(d.ToString("R", CultureInfo.InvariantCulture))).ConfigureAwait(false);
                // always mark a double as being a double in case we have no decimal portion (e.g write 1D instead of 1 which is an int)
                await (Output.WriteAsync('D')).ConfigureAwait(false);
            }
        }

        private async Task GenerateDecimalValueAsync(decimal d)
        {
            await (Output.WriteAsync(d.ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
            await (Output.WriteAsync('m')).ConfigureAwait(false);
        }

        private async Task OutputOperatorAsync(CodeBinaryOperatorType op)
        {
            switch (op)
            {
                case CodeBinaryOperatorType.Add:
                    await (Output.WriteAsync('+')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.Subtract:
                    await (Output.WriteAsync('-')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.Multiply:
                    await (Output.WriteAsync('*')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.Divide:
                    await (Output.WriteAsync('/')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.Modulus:
                    await (Output.WriteAsync('%')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.Assign:
                    await (Output.WriteAsync('=')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.IdentityInequality:
                    await (Output.WriteAsync("!=")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.IdentityEquality:
                    await (Output.WriteAsync("==")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.ValueEquality:
                    await (Output.WriteAsync("==")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.BitwiseOr:
                    await (Output.WriteAsync('|')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.BitwiseAnd:
                    await (Output.WriteAsync('&')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.BooleanOr:
                    await (Output.WriteAsync("||")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.BooleanAnd:
                    await (Output.WriteAsync("&&")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.LessThan:
                    await (Output.WriteAsync('<')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.LessThanOrEqual:
                    await (Output.WriteAsync("<=")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.GreaterThan:
                    await (Output.WriteAsync('>')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.GreaterThanOrEqual:
                    await (Output.WriteAsync(">=")).ConfigureAwait(false);
                    break;
            }
        }

        private async Task GeneratePropertyReferenceExpressionAsync(CodePropertyReferenceExpression e)
        {
            if (e.TargetObject != null)
            {
                await (GenerateExpressionAsync(e.TargetObject)).ConfigureAwait(false);
                await (Output.WriteAsync('.')).ConfigureAwait(false);
            }
            await (OutputIdentifierAsync(e.PropertyName)).ConfigureAwait(false);
        }

        private Task GenerateTypeReferenceExpressionAsync(CodeTypeReferenceExpression e) =>
            OutputTypeAsync(e.Type);

        private async Task GenerateTypeOfExpressionAsync(CodeTypeOfExpression e)
        {
            await (Output.WriteAsync("typeof(")).ConfigureAwait(false);
            await (OutputTypeAsync(e.Type)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        private Task OutputExpressionListAsync(CodeExpressionCollection expressions)
        {
            return OutputExpressionListAsync(expressions, false /*newlineBetweenItems*/);
        }

        private async Task OutputExpressionListAsync(CodeExpressionCollection expressions, bool newlineBetweenItems)
        {
            bool first = true;
            Indent++;
            foreach (CodeExpression current in expressions)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    if (newlineBetweenItems)
                        await (ContinueOnNewLineAsync(",")).ConfigureAwait(false);
                    else
                        await (Output.WriteAsync(", ")).ConfigureAwait(false);
                }
                await (((ICodeGenerator)this).GenerateCodeFromExpressionAsync(current, _output.InnerWriter, _options)).ConfigureAwait(false);
            }
            Indent--;
        }

        private async Task OutputTypeNamePairAsync(CodeTypeReference typeRef, string name)
        {
            await (OutputTypeAsync(typeRef)).ConfigureAwait(false);
            await (Output.WriteAsync(' ')).ConfigureAwait(false);
            await (OutputIdentifierAsync(name)).ConfigureAwait(false);
        }

        private async Task OutputStartingBraceAsync()
        {
            if (Options.BracingStyle == "C")
            {
                await (Output.WriteLineAsync()).ConfigureAwait(false);
                await (Output.WriteLineAsync('{')).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteLineAsync(" {")).ConfigureAwait(false);
            }
        }

        async Task ICodeGenerator.GenerateCodeFromExpressionAsync(CodeExpression e, TextWriter w, CodeGeneratorOptions o)
        {
            bool setLocal = false;
            if (_output != null && w != _output.InnerWriter)
            {
                throw new InvalidOperationException(SR.CodeGenOutputWriter);
            }
            if (_output == null)
            {
                setLocal = true;
                _options = o ?? new CodeGeneratorOptions();
                _output = new ExposedTabStringIndentedTextWriter(w, _options.IndentString);
            }

            try
            {
                await (GenerateExpressionAsync(e)).ConfigureAwait(false);
            }
            finally
            {
                if (setLocal)
                {
                    _output = null;
                    _options = null;
                }
            }
        }

        async Task ICodeGenerator.GenerateCodeFromStatementAsync(CodeStatement e, TextWriter w, CodeGeneratorOptions o)
        {
            bool setLocal = false;
            if (_output != null && w != _output.InnerWriter)
            {
                throw new InvalidOperationException(SR.CodeGenOutputWriter);
            }
            if (_output == null)
            {
                setLocal = true;
                _options = o ?? new CodeGeneratorOptions();
                _output = new ExposedTabStringIndentedTextWriter(w, _options.IndentString);
            }

            try
            {
                await (GenerateStatementAsync(e)).ConfigureAwait(false);
            }
            finally
            {
                if (setLocal)
                {
                    _output = null;
                    _options = null;
                }
            }
        }
    }
}
