//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Globalization;
using System.IO;
using VarDump.Async;
using VarDump.CodeDom.Common;
using VarDump.CodeDom.Resources;

namespace VarDump.CodeDom.Compiler;
using System.Threading.Tasks;

internal abstract partial class CodeGenerator : ICodeGenerator
{

    async Task ICodeGenerator.GenerateCodeFromExpressionAsync(CodeExpression e, TextWriter w, CodeGeneratorOptions o)
    {
        bool setLocal = false;
        if (_output != null && w != _output.InnerWriter)
        {
            throw new InvalidOperationException(SR.CodeGenOutputWriter);
        }
        if (_output == null)
        {
            setLocal = true;
            _options = o ?? new CodeGeneratorOptions();
            _output = new ExposedTabStringIndentedTextWriter(w, _options.IndentString);
        }

        try
        {
            await (GenerateExpressionAsync(e)).ConfigureAwait(false);
        }
        finally
        {
            if (setLocal)
            {
                _output = null;
                _options = null;
            }
        }
    }

    async Task ICodeGenerator.GenerateCodeFromStatementAsync(CodeStatement e, TextWriter w, CodeGeneratorOptions o)
    {
        bool setLocal = false;
        if (_output != null && w != _output.InnerWriter)
        {
            throw new InvalidOperationException(SR.CodeGenOutputWriter);
        }
        if (_output == null)
        {
            setLocal = true;
            _options = o ?? new CodeGeneratorOptions();
            _output = new ExposedTabStringIndentedTextWriter(w, _options.IndentString);
        }

        try
        {
            await (GenerateStatementAsync(e)).ConfigureAwait(false);
        }
        finally
        {
            if (setLocal)
            {
                _output = null;
                _options = null;
            }
        }
    }

    protected Task GenerateExpressionAsync(CodeExpression e)
    {
        try
        {
            if (e is CodeStatementExpression)
            {
                return GenerateStatementExpressionAsync((CodeStatementExpression)e);
            }
            else if (e is CodeSeparatedExpressionCollection)
            {
                return GenerateSeparatedExpressionCollectionAsync((CodeSeparatedExpressionCollection)e);
            }
            else if (e is CodeArrayCreateExpression)
            {
                return GenerateArrayCreateExpressionAsync((CodeArrayCreateExpression)e);
            }
            else if (e is CodeArrayDimensionExpression)
            {
                return GenerateCodeArrayDimensionExpressionAsync((CodeArrayDimensionExpression)e);
            }
            else if (e is CodeFlagsBinaryOperatorExpression)
            {
                return GenerateFlagsBinaryOperatorExpressionAsync((CodeFlagsBinaryOperatorExpression)e);
            }
            else if (e is CodeBinaryOperatorExpression)
            {
                return GenerateBinaryOperatorExpressionAsync((CodeBinaryOperatorExpression)e);
            }
            else if (e is CodeCastExpression)
            {
                return GenerateCastExpressionAsync((CodeCastExpression)e);
            }
            else if (e is CodeFieldReferenceExpression)
            {
                return GenerateFieldReferenceExpressionAsync((CodeFieldReferenceExpression)e);
            }
            else if (e is CodeVariableReferenceExpression)
            {
                return GenerateVariableReferenceExpressionAsync((CodeVariableReferenceExpression)e);
            }
            else if (e is CodeSnippetExpression)
            {
                return GenerateSnippetExpressionAsync((CodeSnippetExpression)e);
            }
            else if (e is CodeMethodInvokeExpression)
            {
                return GenerateMethodInvokeExpressionAsync((CodeMethodInvokeExpression)e);
            }
            else if (e is CodeMethodReferenceExpression)
            {
                return GenerateMethodReferenceExpressionAsync((CodeMethodReferenceExpression)e);
            }
            else if (e is CodeObjectCreateAndInitializeExpression)
            {
                return GenerateObjectCreateAndInitializeExpressionAsync((CodeObjectCreateAndInitializeExpression)e);
            }
            else if (e is CodeNamedArgumentExpression na)
            {
                return GenerateNamedArgumentExpressionAsync(na);
            }
            else if (e is CodeValueTupleCreateExpression)
            {
                return GenerateValueTupleCreateExpressionAsync((CodeValueTupleCreateExpression)e);
            }
            else if (e is CodeObjectCreateExpression)
            {
                return GenerateObjectCreateExpressionAsync((CodeObjectCreateExpression)e);
            }
            else if (e is CodeLambdaExpression)
            {
                return GenerateLambdaExpressionAsync((CodeLambdaExpression)e);
            }
            else if (e is CodePrimitiveExpression)
            {
                return GeneratePrimitiveExpressionAsync((CodePrimitiveExpression)e);
            }
            else if (e is CodePropertyReferenceExpression)
            {
                return GeneratePropertyReferenceExpressionAsync((CodePropertyReferenceExpression)e);
            }
            else if (e is CodeTypeReferenceExpression)
            {
                return GenerateTypeReferenceExpressionAsync((CodeTypeReferenceExpression)e);
            }
            else if (e is CodeTypeOfExpression)
            {
                return GenerateTypeOfExpressionAsync((CodeTypeOfExpression)e);
            }
            else if (e is CodeDefaultValueExpression)
            {
                return GenerateDefaultValueExpressionAsync((CodeDefaultValueExpression)e);
            }
            else if (e is CodeAssignExpression)
            {
                return GenerateCodeAssignExpressionAsync((CodeAssignExpression)e);
            }
            else if (e is CodeImplicitKeyValuePairCreateExpression)
            {
                return GenerateCodeImplicitKeyValuePairCreateExpressionAsync((CodeImplicitKeyValuePairCreateExpression)e);
            }
            else
            {
                if (e == null)
                {
                    return TaskPolyfills.FromException(new ArgumentNullException(nameof(e)));
                }
                else
                {
                    return TaskPolyfills.FromException(new ArgumentException(SR.Format(SR.InvalidElementType, e.GetType().FullName), nameof(e)));
                }
            }
        }
        catch (Exception ex)
        {
            return TaskPolyfills.FromException(ex);
        }
    }



    protected async Task GenerateStatementAsync(CodeStatement e)
    {
        if (e is CodeCommentStatement)
        {
            await (GenerateCommentStatementAsync((CodeCommentStatement)e)).ConfigureAwait(false);
        }
        else if (e is CodeConditionStatement)
        {
            await (GenerateConditionStatementAsync((CodeConditionStatement)e)).ConfigureAwait(false);
        }
        else if (e is CodeAssignStatement)
        {
            await (GenerateAssignStatementAsync((CodeAssignStatement)e)).ConfigureAwait(false);
        }
        else if (e is CodeExpressionStatement)
        {
            await (GenerateExpressionStatementAsync((CodeExpressionStatement)e)).ConfigureAwait(false);
        }
        else if (e is CodeSnippetStatement)
        {
            // Don't indent snippet statements, in order to preserve the column
            // information from the original code.  This improves the debugging
            // experience.
            int savedIndent = Indent;
            Indent = 0;

            await (GenerateSnippetStatementAsync((CodeSnippetStatement)e)).ConfigureAwait(false);

            // Restore the indent
            Indent = savedIndent;
        }
        else if (e is CodeVariableDeclarationStatement)
        {
            await (GenerateVariableDeclarationStatementAsync((CodeVariableDeclarationStatement)e)).ConfigureAwait(false);
        }
        else
        {
            throw new ArgumentException(SR.Format(SR.InvalidElementType, e.GetType().FullName), nameof(e));
        }
    }

    protected async Task GenerateStatementsAsync(CodeStatementCollection stmts)
    {
        foreach (CodeStatement stmt in stmts)
        {
            await (((ICodeGenerator)this).GenerateCodeFromStatementAsync(stmt, _output.InnerWriter, _options)).ConfigureAwait(false);
        }
    }

    protected abstract Task OutputTypeAsync(CodeTypeReference typeRef);

    protected virtual Task OutputIdentifierAsync(string ident)
    {
        return Output.WriteAsync(ident);
    }

    protected virtual Task OutputExpressionListAsync(CodeExpressionCollection expressions)
    {
        return OutputExpressionListAsync(expressions, newlineBetweenItems: false);
    }

    protected virtual async Task OutputExpressionListAsync(CodeExpressionCollection expressions, bool newlineBetweenItems,
        bool newLineContinuation = true)
    {
        bool first = true;
        Indent++;
        foreach (CodeExpression current in expressions)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                if (newlineBetweenItems)
                    await (ContinueOnNewLineAsync(",", newLineContinuation)).ConfigureAwait(false);
                else
                    await (Output.WriteAsync(", ")).ConfigureAwait(false);
            }
            await (((ICodeGenerator)this).GenerateCodeFromExpressionAsync(current, _output.InnerWriter, _options)).ConfigureAwait(false);
        }
        Indent--;
    }

    protected virtual async Task OutputOperatorAsync(CodeBinaryOperatorType op)
    {
        switch (op)
        {
            case CodeBinaryOperatorType.Add:
                await (Output.WriteAsync('+')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.Subtract:
                await (Output.WriteAsync('-')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.Multiply:
                await (Output.WriteAsync('*')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.Divide:
                await (Output.WriteAsync('/')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.Modulus:
                await (Output.WriteAsync('%')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.Assign:
                await (Output.WriteAsync('=')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.IdentityInequality:
                await (Output.WriteAsync("!=")).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.IdentityEquality:
                await (Output.WriteAsync("==")).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.ValueEquality:
                await (Output.WriteAsync("==")).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.BitwiseOr:
                await (Output.WriteAsync('|')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.BitwiseAnd:
                await (Output.WriteAsync('&')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.BooleanOr:
                await (Output.WriteAsync("||")).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.BooleanAnd:
                await (Output.WriteAsync("&&")).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.LessThan:
                await (Output.WriteAsync('<')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.LessThanOrEqual:
                await (Output.WriteAsync("<=")).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.GreaterThan:
                await (Output.WriteAsync('>')).ConfigureAwait(false);
                break;
            case CodeBinaryOperatorType.GreaterThanOrEqual:
                await (Output.WriteAsync(">=")).ConfigureAwait(false);
                break;
        }
    }

    protected abstract Task GenerateArrayCreateExpressionAsync(CodeArrayCreateExpression e);

    protected abstract Task GenerateCodeArrayDimensionExpressionAsync(CodeArrayDimensionExpression e);

    protected async Task GenerateFlagsBinaryOperatorExpressionAsync(CodeFlagsBinaryOperatorExpression e)
    {
        if (e.Expressions.Count == 0) return;

        bool isFirst = true;

        foreach (CodeExpression expression in e.Expressions)
        {
            if (isFirst)
            {
                await (GenerateExpressionAsync(e.Expressions[0])).ConfigureAwait(false);
                isFirst = false;
            }
            else
            {
                await (Output.WriteAsync(' ')).ConfigureAwait(false);
                await (OutputOperatorAsync(e.Operator)).ConfigureAwait(false);
                await (Output.WriteAsync(' ')).ConfigureAwait(false);
                await (GenerateExpressionAsync(expression)).ConfigureAwait(false);
            }
        }
    }

    protected virtual async Task GenerateBinaryOperatorExpressionAsync(CodeBinaryOperatorExpression e)
    {
        bool indentedExpression = false;
        await (Output.WriteAsync('(')).ConfigureAwait(false);

        await (GenerateExpressionAsync(e.Left)).ConfigureAwait(false);
        await (Output.WriteAsync(' ')).ConfigureAwait(false);

        if (e.Left is CodeBinaryOperatorExpression || e.Right is CodeBinaryOperatorExpression)
        {
            // In case the line gets too long with nested binary operators, we need to output them on
            // different lines. However we want to indent them to maintain readability, but this needs
            // to be done only once;
            if (!_inNestedBinary)
            {
                indentedExpression = true;
                _inNestedBinary = true;
                Indent += 3;
            }
            await (ContinueOnNewLineAsync("")).ConfigureAwait(false);
        }

        await (OutputOperatorAsync(e.Operator)).ConfigureAwait(false);

        await (Output.WriteAsync(' ')).ConfigureAwait(false);
        await (GenerateExpressionAsync(e.Right)).ConfigureAwait(false);

        await (Output.WriteAsync(')')).ConfigureAwait(false);
        if (indentedExpression)
        {
            Indent -= 3;
            _inNestedBinary = false;
        }
    }

    protected virtual Task ContinueOnNewLineAsync(string st, bool newLineContinuation = true) => Output.WriteLineAsync(st);

    protected abstract Task GenerateCastExpressionAsync(CodeCastExpression e);
    protected abstract Task GenerateFieldReferenceExpressionAsync(CodeFieldReferenceExpression e);
    protected abstract Task GenerateVariableReferenceExpressionAsync(CodeVariableReferenceExpression e);
    protected abstract Task GenerateSnippetExpressionAsync(CodeSnippetExpression e);
    protected abstract Task GenerateMethodInvokeExpressionAsync(CodeMethodInvokeExpression e);
    protected abstract Task GenerateMethodReferenceExpressionAsync(CodeMethodReferenceExpression e);
    protected abstract Task GenerateValueTupleCreateExpressionAsync(CodeValueTupleCreateExpression e);
    protected abstract Task GenerateCodeImplicitKeyValuePairCreateExpressionAsync(CodeImplicitKeyValuePairCreateExpression e);
    protected abstract Task GenerateStatementExpressionAsync(CodeStatementExpression e);
    protected abstract Task GenerateSeparatedExpressionCollectionAsync(CodeSeparatedExpressionCollection e);
    protected abstract Task GenerateObjectCreateExpressionAsync(CodeObjectCreateExpression e);
    protected abstract Task GenerateLambdaExpressionAsync(CodeLambdaExpression e);
    protected abstract Task GenerateObjectCreateAndInitializeExpressionAsync(CodeObjectCreateAndInitializeExpression e);
    protected abstract Task GenerateNamedArgumentExpressionAsync(CodeNamedArgumentExpression e);
    protected abstract Task GenerateCodeAssignExpressionAsync(CodeAssignExpression e);
    protected virtual Task GeneratePrimitiveExpressionAsync(CodePrimitiveExpression e)
    {
        try
        {
            if (e.Value == null)
            {
                return Output.WriteAsync(NullToken);
            }
            else if (e.Value is string)
            {
                return Output.WriteAsync(QuoteSnippetString((string)e.Value));
            }
            else if (e.Value is char)
            {
                return Output.WriteAsync("'" + e.Value + "'");
            }
            else if (e.Value is byte)
            {
                return Output.WriteAsync(((byte)e.Value).ToString(CultureInfo.InvariantCulture));
            }
            else if (e.Value is short)
            {
                return Output.WriteAsync(((short)e.Value).ToString(CultureInfo.InvariantCulture));
            }
            else if (e.Value is int)
            {
                return Output.WriteAsync(((int)e.Value).ToString(CultureInfo.InvariantCulture));
            }
            else if (e.Value is long)
            {
                return Output.WriteAsync(((long)e.Value).ToString(CultureInfo.InvariantCulture));
            }
            else if (e.Value is float)
            {
                return GenerateSingleFloatValueAsync((float)e.Value);
            }
            else if (e.Value is double)
            {
                return GenerateDoubleValueAsync((double)e.Value);
            }
            else if (e.Value is decimal)
            {
                return GenerateDecimalValueAsync((decimal)e.Value);
            }
            else if (e.Value is bool)
            {
                if ((bool)e.Value)
                {
                    return Output.WriteAsync("true");
                }
                else
                {
                    return Output.WriteAsync("false");
                }
            }
            else
            {
                return TaskPolyfills.FromException(new ArgumentException(SR.Format(SR.InvalidPrimitiveType, e.Value.GetType().ToString())));
            }
        }
        catch (Exception ex)
        {
            return TaskPolyfills.FromException(ex);
        }
    }

    protected virtual Task GenerateSingleFloatValueAsync(float s) => Output.WriteAsync(s.ToString("R", CultureInfo.InvariantCulture));

    protected virtual Task GenerateDoubleValueAsync(double d) => Output.WriteAsync(d.ToString("R", CultureInfo.InvariantCulture));

    protected virtual Task GenerateDecimalValueAsync(decimal d) => Output.WriteAsync(d.ToString(CultureInfo.InvariantCulture));

    protected virtual Task GenerateDefaultValueExpressionAsync(CodeDefaultValueExpression e)
    {
        try
        {
            GenerateDefaultValueExpression(e);
            return TaskPolyfills.CompletedTask;
        }
        catch (Exception ex)
        {
            return TaskPolyfills.FromException(ex);
        }
    }

    protected abstract Task GeneratePropertyReferenceExpressionAsync(CodePropertyReferenceExpression e);

    protected virtual Task GenerateTypeReferenceExpressionAsync(CodeTypeReferenceExpression e)
    {
        return OutputTypeAsync(e.Type);
    }

    protected virtual async Task GenerateTypeOfExpressionAsync(CodeTypeOfExpression e)
    {
        await (Output.WriteAsync("typeof(")).ConfigureAwait(false);
        await (OutputTypeAsync(e.Type)).ConfigureAwait(false);
        await (Output.WriteAsync(')')).ConfigureAwait(false);
    }

    protected abstract Task GenerateExpressionStatementAsync(CodeExpressionStatement e);
    protected virtual Task GenerateCommentStatementAsync(CodeCommentStatement e)
    {
        if (e.Comment == null)
        {
            throw new ArgumentException(SR.Format(SR.Argument_NullComment, nameof(e)), nameof(e));
        }
        return GenerateCommentAsync(e.Comment);
    }

    protected virtual async Task GenerateCommentStatementsAsync(CodeCommentStatementCollection e)
    {
        foreach (CodeCommentStatement comment in e)
        {
            await (GenerateCommentStatementAsync(comment)).ConfigureAwait(false);
        }
    }

    protected abstract Task GenerateCommentAsync(CodeComment e);
    protected abstract Task GenerateConditionStatementAsync(CodeConditionStatement e);
    protected abstract Task GenerateAssignStatementAsync(CodeAssignStatement e);
    protected virtual Task GenerateSnippetStatementAsync(CodeSnippetStatement e) => Output.WriteLineAsync(e.Value);
    protected abstract Task GenerateVariableDeclarationStatementAsync(CodeVariableDeclarationStatement e);
}