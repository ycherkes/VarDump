//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using VarDump.Async;
using VarDump.CodeDom.Collections.Specialized;
using VarDump.CodeDom.Common;
using VarDump.CodeDom.Compiler;

namespace VarDump.CodeDom.VisualBasic
{
    using System.Threading.Tasks;
    internal sealed partial class VBCodeGenerator : CodeGenerator
    {

        protected override async Task GenerateNamedArgumentExpressionAsync(CodeNamedArgumentExpression e)
        {
            await (Output.WriteAsync(e.Name)).ConfigureAwait(false);
            await (Output.WriteAsync(":=")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Value)).ConfigureAwait(false);
        }

        protected override async Task GenerateCodeAssignExpressionAsync(CodeAssignExpression e)
        {
            await (GenerateExpressionAsync(e.Left)).ConfigureAwait(false);
            await (Output.WriteAsync(" = ")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Right)).ConfigureAwait(false);
        }

        protected override Task GenerateDefaultValueExpressionAsync(CodeDefaultValueExpression e)
        {
            try
            {
                return Output.WriteAsync("CType(Nothing, " + GetTypeOutput(e.Type) + ")");
            }
            catch (Exception ex)
            {
                return TaskPolyfills.FromException(ex);
            }
        }

        protected override async Task OutputOperatorAsync(CodeBinaryOperatorType op)
        {
            switch (op)
            {
                case CodeBinaryOperatorType.IdentityInequality:
                    await (Output.WriteAsync("<>")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.IdentityEquality:
                    await (Output.WriteAsync("Is")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.BooleanOr:
                    await (Output.WriteAsync("OrElse")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.BooleanAnd:
                    await (Output.WriteAsync("AndAlso")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.ValueEquality:
                    await (Output.WriteAsync('=')).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.Modulus:
                    await (Output.WriteAsync("Mod")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.BitwiseOr:
                    await (Output.WriteAsync("Or")).ConfigureAwait(false);
                    break;
                case CodeBinaryOperatorType.BitwiseAnd:
                    await (Output.WriteAsync("And")).ConfigureAwait(false);
                    break;
                default:
                    await (base.OutputOperatorAsync(op)).ConfigureAwait(false);
                    break;
            }
        }

        private async Task GenerateNotIsNullExpressionAsync(CodeExpression e)
        {
            await (Output.WriteAsync("(Not (")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e)).ConfigureAwait(false);
            await (Output.WriteAsync(") Is ")).ConfigureAwait(false);
            await (Output.WriteAsync(NullToken)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        protected override async Task GenerateBinaryOperatorExpressionAsync(CodeBinaryOperatorExpression e)
        {
            if (e.Operator != CodeBinaryOperatorType.IdentityInequality)
            {
                await (base.GenerateBinaryOperatorExpressionAsync(e)).ConfigureAwait(false);
                return;
            }

            // "o <> nothing" should be "not o is nothing"
            if (e.Right is CodePrimitiveExpression && ((CodePrimitiveExpression)e.Right).Value == null)
            {
                await (GenerateNotIsNullExpressionAsync(e.Left)).ConfigureAwait(false);
                return;
            }
            if (e.Left is CodePrimitiveExpression && ((CodePrimitiveExpression)e.Left).Value == null)
            {
                await (GenerateNotIsNullExpressionAsync(e.Right)).ConfigureAwait(false);
                return;
            }

            await (base.GenerateBinaryOperatorExpressionAsync(e)).ConfigureAwait(false);
        }

        protected override Task OutputIdentifierAsync(string ident)
        {
            try
            {
                return Output.WriteAsync(CreateEscapedIdentifier(ident));
            }
            catch (Exception ex)
            {
                return TaskPolyfills.FromException(ex);
            }
        }

        protected override Task OutputTypeAsync(CodeTypeReference typeRef)
        {
            try
            {
                return Output.WriteAsync(GetTypeOutputWithoutArrayPostFix(typeRef));
            }
            catch (Exception ex)
            {
                return TaskPolyfills.FromException(ex);
            }
        }


        private async Task OutputTypeNamePairAsync(CodeTypeReference typeRef, string name)
        {
            if (string.IsNullOrEmpty(name))
                name = "__exception";

            await (OutputIdentifierAsync(name)).ConfigureAwait(false);
            await (OutputArrayPostfixAsync(typeRef)).ConfigureAwait(false);
            if (!(typeRef is CodeEmptyTypeReference))
            {
                await (Output.WriteAsync(" As ")).ConfigureAwait(false);
                await (OutputTypeAsync(typeRef)).ConfigureAwait(false);
            }
        }

        private Task OutputArrayPostfixAsync(CodeTypeReference typeRef)
        {
            try
            {
                if (typeRef.ArrayRank > 0)
                {
                    return Output.WriteAsync(GetArrayPostfix(typeRef));
                }
                return TaskPolyfills.CompletedTask;
            }
            catch (Exception ex)
            {
                return TaskPolyfills.FromException(ex);
            }
        }

        protected override async Task GeneratePrimitiveExpressionAsync(CodePrimitiveExpression e)
        {
            if (e.Value is char)
            {
                await (Output.WriteAsync("Global.Microsoft.VisualBasic.ChrW(" + ((IConvertible)e.Value).ToInt32(CultureInfo.InvariantCulture).ToString(CultureInfo.InvariantCulture) + ")")).ConfigureAwait(false);
            }
            else if (e.Value is sbyte)
            {
                await (Output.WriteAsync("CSByte(")).ConfigureAwait(false);
                await (Output.WriteAsync(((sbyte)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
                await (Output.WriteAsync(')')).ConfigureAwait(false);
            }
            else if (e.Value is ushort)
            {
                await (Output.WriteAsync(((ushort)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
                await (Output.WriteAsync("US")).ConfigureAwait(false);
            }
            else if (e.Value is uint)
            {
                await (Output.WriteAsync(((uint)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
                await (Output.WriteAsync("UI")).ConfigureAwait(false);
            }
            else if (e.Value is ulong)
            {
                await (Output.WriteAsync(((ulong)e.Value).ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
                await (Output.WriteAsync("UL")).ConfigureAwait(false);
            }
            else
            {
                await (base.GeneratePrimitiveExpressionAsync(e)).ConfigureAwait(false);
            }
        }

        protected override async Task GenerateArrayCreateExpressionAsync(CodeArrayCreateExpression e)
        {
            if (!(e.CreateType is CodeEmptyTypeReference))
            {
                await (Output.WriteAsync("New ")).ConfigureAwait(false);
            }

            CodeExpressionCollection init = e.Initializers;
            if (init.Count > 0)
            {
                if (!(e.CreateType is CodeEmptyTypeReference))
                {
                    string typeName = GetTypeOutput(e.CreateType);
                    await (Output.WriteAsync(typeName)).ConfigureAwait(false);
                }

                await (Output.WriteAsync("{")).ConfigureAwait(false);
                await (Output.WriteLineAsync("")).ConfigureAwait(false);
                await (OutputExpressionListAsync(init, newlineBetweenItems: true, newLineContinuation: false)).ConfigureAwait(false);
                await (Output.WriteLineAsync("")).ConfigureAwait(false);
                await (Output.WriteAsync('}')).ConfigureAwait(false);
            }
            else
            {
                string typeName = GetTypeOutput(e.CreateType);

                int index = typeName.IndexOf('(');
                if (index == -1)
                {
                    await (Output.WriteAsync(typeName)).ConfigureAwait(false);
                    await (Output.WriteAsync('(')).ConfigureAwait(false);
                }
                else
                {
                    await (Output.WriteAsync(typeName.Substring(0, index + 1))).ConfigureAwait(false);
                }

                // The tricky thing is we need to declare the size - 1
                if (e.SizeExpression != null)
                {
                    await (Output.WriteAsync('(')).ConfigureAwait(false);
                    await (GenerateExpressionAsync(e.SizeExpression)).ConfigureAwait(false);
                    await (Output.WriteAsync(") - 1")).ConfigureAwait(false);
                }
                else
                {
                    Output.Write(e.Size - 1);
                }

                if (index == -1)
                {
                    await (Output.WriteAsync(')')).ConfigureAwait(false);
                }
                else
                {
                    await (Output.WriteAsync(typeName.Substring(index + 1))).ConfigureAwait(false);
                }

                await (Output.WriteAsync(" {}")).ConfigureAwait(false);
            }
        }

        protected override async Task GenerateCodeArrayDimensionExpressionAsync(CodeArrayDimensionExpression e)
        {
            await (Output.WriteAsync("{")).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
            await (OutputExpressionListAsync(e.Initializers, newlineBetweenItems: true, newLineContinuation: false)).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
            await (Output.WriteAsync("}")).ConfigureAwait(false);
        }

        protected override async Task GenerateCastExpressionAsync(CodeCastExpression e)
        {
            await (Output.WriteAsync("CType(")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Expression)).ConfigureAwait(false);
            await (Output.WriteAsync(", ")).ConfigureAwait(false);
            await (OutputTypeAsync(e.TargetType)).ConfigureAwait(false);
            await (OutputArrayPostfixAsync(e.TargetType)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        protected override async Task GenerateFieldReferenceExpressionAsync(CodeFieldReferenceExpression e)
        {
            if (e.TargetObject != null)
            {
                await (GenerateExpressionAsync(e.TargetObject)).ConfigureAwait(false);
                await (Output.WriteAsync('.')).ConfigureAwait(false);
            }

            await (OutputIdentifierAsync(e.FieldName)).ConfigureAwait(false);
        }

        protected override async Task GenerateSingleFloatValueAsync(float s)
        {
            if (float.IsNaN(s))
            {
                await (Output.WriteAsync("Single.NaN")).ConfigureAwait(false);
            }
            else if (float.IsNegativeInfinity(s))
            {
                await (Output.WriteAsync("Single.NegativeInfinity")).ConfigureAwait(false);
            }
            else if (float.IsPositiveInfinity(s))
            {
                await (Output.WriteAsync("Single.PositiveInfinity")).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteAsync(s.ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
                await (Output.WriteAsync('!')).ConfigureAwait(false);
            }
        }

        protected override async Task GenerateDoubleValueAsync(double d)
        {
            if (double.IsNaN(d))
            {
                await (Output.WriteAsync("Double.NaN")).ConfigureAwait(false);
            }
            else if (double.IsNegativeInfinity(d))
            {
                await (Output.WriteAsync("Double.NegativeInfinity")).ConfigureAwait(false);
            }
            else if (double.IsPositiveInfinity(d))
            {
                await (Output.WriteAsync("Double.PositiveInfinity")).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteAsync(d.ToString("R", CultureInfo.InvariantCulture))).ConfigureAwait(false);
                // always mark a double as being a double in case we have no decimal portion (e.g write 1D instead of 1 which is an int)
                await (Output.WriteAsync('R')).ConfigureAwait(false);
            }
        }

        protected override async Task GenerateDecimalValueAsync(decimal d)
        {
            await (Output.WriteAsync(d.ToString(CultureInfo.InvariantCulture))).ConfigureAwait(false);
            await (Output.WriteAsync('D')).ConfigureAwait(false);
        }

        protected override Task GenerateVariableReferenceExpressionAsync(CodeVariableReferenceExpression e)
        {
            return OutputIdentifierAsync(e.VariableName);
        }

        protected override Task GenerateSnippetExpressionAsync(CodeSnippetExpression e)
        {
            return Output.WriteAsync(e.Value);
        }

        protected override async Task GenerateMethodInvokeExpressionAsync(CodeMethodInvokeExpression e)
        {
            await (GenerateMethodReferenceExpressionAsync(e.Method)).ConfigureAwait(false);
            CodeExpressionCollection parameters = e.Parameters;
            if (parameters.Count > 0)
            {
                await (Output.WriteAsync('(')).ConfigureAwait(false);
                await (OutputExpressionListAsync(e.Parameters)).ConfigureAwait(false);
                await (Output.WriteAsync(')')).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteAsync("()")).ConfigureAwait(false);
            }
        }

        protected override async Task GenerateMethodReferenceExpressionAsync(CodeMethodReferenceExpression e)
        {
            if (e.TargetObject != null)
            {
                await (GenerateExpressionAsync(e.TargetObject)).ConfigureAwait(false);
                await (Output.WriteAsync('.')).ConfigureAwait(false);
                await (Output.WriteAsync(e.MethodName)).ConfigureAwait(false);
            }
            else
            {
                await (OutputIdentifierAsync(e.MethodName)).ConfigureAwait(false);
            }

            if (e.TypeArguments.Count > 0)
            {
                await (Output.WriteAsync(GetTypeArgumentsOutput(e.TypeArguments))).ConfigureAwait(false);
            }
        }

        protected override async Task GenerateObjectCreateAndInitializeExpressionAsync(CodeObjectCreateAndInitializeExpression e)
        {
            await (Output.WriteAsync("New ")).ConfigureAwait(false);
            await (OutputTypeAsync(e.CreateType)).ConfigureAwait(false);
            if (e.Parameters.Count > 0 || e.InitializeExpressions.Count == 0)
            {
                // always write out the () to disambiguate cases like "New System.Random().Next(x,y)"
                await (Output.WriteAsync('(')).ConfigureAwait(false);
                await (OutputExpressionListAsync(e.Parameters)).ConfigureAwait(false);
                await (Output.WriteAsync(')')).ConfigureAwait(false);
            }

            if (e.InitializeExpressions.Count <= 0) return;

            await (Output.WriteAsync(e.CreateType switch
            {
                CodeEmptyTypeReference => "With ",
                CodeCollectionTypeReference => " From ",
                _ => " With "
            })).ConfigureAwait(false);
            await (Output.WriteLineAsync('{')).ConfigureAwait(false);
            await (OutputExpressionListAsync(e.InitializeExpressions, newlineBetweenItems: true, newLineContinuation: false)).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
            await (Output.WriteAsync("}")).ConfigureAwait(false);
        }

        protected override async Task GenerateValueTupleCreateExpressionAsync(CodeValueTupleCreateExpression e)
        {
            await (Output.WriteAsync('(')).ConfigureAwait(false);
            await (OutputExpressionListAsync(e.Parameters)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        protected override async Task GenerateCodeImplicitKeyValuePairCreateExpressionAsync(CodeImplicitKeyValuePairCreateExpression e)
        {
            await (Output.WriteLineAsync('{')).ConfigureAwait(false);
            await (OutputExpressionListAsync(new CodeExpressionCollection(new[] { e.Key, e.Value }), true, false)).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
            await (Output.WriteAsync('}')).ConfigureAwait(false);
        }

        protected override Task GenerateStatementExpressionAsync(CodeStatementExpression e)
        {
            return GenerateStatementAsync(e.Statement);
        }

        protected override async Task GenerateSeparatedExpressionCollectionAsync(CodeSeparatedExpressionCollection e)
        {
            var collectionLength = e.ExpressionCollection.Count;
            int current = 0;

            foreach (CodeExpression codeExpression in e.ExpressionCollection)
            {
                current++;
                await (GenerateExpressionAsync(codeExpression)).ConfigureAwait(false);
                if (current < collectionLength)
                {
                    await (Output.WriteAsync(e.Separator)).ConfigureAwait(false);
                }
            }
        }

        protected override async Task GenerateObjectCreateExpressionAsync(CodeObjectCreateExpression e)
        {
            await (Output.WriteAsync("New ")).ConfigureAwait(false);
            await (OutputTypeAsync(e.CreateType)).ConfigureAwait(false);
            // always write out the () to disambiguate cases like "New System.Random().Next(x,y)"
            await (Output.WriteAsync('(')).ConfigureAwait(false);
            await (OutputExpressionListAsync(e.Parameters)).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        protected override async Task GenerateLambdaExpressionAsync(CodeLambdaExpression codeLambdaExpression)
        {
            await (Output.WriteAsync("Function (")).ConfigureAwait(false);
            bool first = true;

            foreach (CodeExpression current in codeLambdaExpression.Parameters)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    await (Output.WriteAsync(", ")).ConfigureAwait(false);
                }
                await (GenerateExpressionAsync(current)).ConfigureAwait(false);
            }

            await (Output.WriteAsync(')')).ConfigureAwait(false);
            await (Output.WriteAsync(" ")).ConfigureAwait(false);
            await (GenerateExpressionAsync(codeLambdaExpression.LambdaExpression)).ConfigureAwait(false);
        }

        protected override async Task GenerateExpressionStatementAsync(CodeExpressionStatement e)
        {
            await (GenerateExpressionAsync(e.Expression)).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
        }

        protected override async Task GenerateCommentStatementsAsync(CodeCommentStatementCollection e)
        {
            // since the compiler emits a warning if XML DocComment blocks appear before
            //  normal comments, we need to output non-DocComments first, followed by
            //  DocComments.
            //            
            foreach (CodeCommentStatement comment in e)
            {
                if (!IsDocComment(comment))
                {
                    await (GenerateCommentStatementAsync(comment)).ConfigureAwait(false);
                }
            }

            foreach (CodeCommentStatement comment in e)
            {
                if (IsDocComment(comment))
                {
                    await (GenerateCommentStatementAsync(comment)).ConfigureAwait(false);
                }
            }
        }

        protected override async Task GenerateCommentAsync(CodeComment e)
        {
            string commentLineStart = e.DocComment ? "'''" : "'";
            await (Output.WriteAsync(commentLineStart)).ConfigureAwait(false);
            string value = e.Text;
            for (int i = 0; i < value.Length; i++)
            {
                await (Output.WriteAsync(value[i])).ConfigureAwait(false);

                if (value[i] == '\r')
                {
                    if (i < value.Length - 1 && value[i + 1] == '\n')
                    { // if next char is '\n', skip it
                        await (Output.WriteAsync('\n')).ConfigureAwait(false);
                        i++;
                    }
                    await (((ExposedTabStringIndentedTextWriter)Output).InternalOutputTabsAsync()).ConfigureAwait(false);
                    await (Output.WriteAsync(commentLineStart)).ConfigureAwait(false);
                }
                else if (value[i] == '\n')
                {
                    await (((ExposedTabStringIndentedTextWriter)Output).InternalOutputTabsAsync()).ConfigureAwait(false);
                    await (Output.WriteAsync(commentLineStart)).ConfigureAwait(false);
                }
                else if (value[i] == '\u2028' || value[i] == '\u2029' || value[i] == '\u0085')
                {
                    await (Output.WriteAsync(commentLineStart)).ConfigureAwait(false);
                }
            }
            if (!e.NoNewLine)
            {
                await (Output.WriteLineAsync()).ConfigureAwait(false);
            }
        }

        protected override async Task GenerateConditionStatementAsync(CodeConditionStatement e)
        {
            await (Output.WriteAsync("If ")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Condition)).ConfigureAwait(false);
            await (Output.WriteLineAsync(" Then")).ConfigureAwait(false);
            Indent++;
            await (GenerateVBStatementsAsync(e.TrueStatements)).ConfigureAwait(false);
            Indent--;

            CodeStatementCollection falseStatemetns = e.FalseStatements;
            if (falseStatemetns.Count > 0)
            {
                await (Output.WriteAsync("Else")).ConfigureAwait(false);
                await (Output.WriteLineAsync()).ConfigureAwait(false);
                Indent++;
                await (GenerateVBStatementsAsync(e.FalseStatements)).ConfigureAwait(false);
                Indent--;
            }
            await (Output.WriteLineAsync("End If")).ConfigureAwait(false);
        }

        protected override async Task GenerateAssignStatementAsync(CodeAssignStatement e)
        {
            await (GenerateExpressionAsync(e.Left)).ConfigureAwait(false);
            await (Output.WriteAsync(" = ")).ConfigureAwait(false);
            await (GenerateExpressionAsync(e.Right)).ConfigureAwait(false);
            await (Output.WriteLineAsync()).ConfigureAwait(false);
        }

        protected override Task GenerateSnippetStatementAsync(CodeSnippetStatement e)
        {
            return Output.WriteLineAsync(e.Value);
        }

        protected override async Task GenerateVariableDeclarationStatementAsync(CodeVariableDeclarationStatement e)
        {
            bool doInit = true;

            await (Output.WriteAsync("Dim ")).ConfigureAwait(false);

            CodeTypeReference typeRef = e.Type;
            if (typeRef.ArrayRank == 1 && e.InitExpression != null)
            {
                CodeArrayCreateExpression eAsArrayCreate = e.InitExpression as CodeArrayCreateExpression;
                if (eAsArrayCreate != null && eAsArrayCreate.Initializers.Count == 0)
                {
                    doInit = false;
                    await (OutputIdentifierAsync(e.Name)).ConfigureAwait(false);
                    await (Output.WriteAsync('(')).ConfigureAwait(false);

                    if (eAsArrayCreate.SizeExpression != null)
                    {
                        await (Output.WriteAsync('(')).ConfigureAwait(false);
                        await (GenerateExpressionAsync(eAsArrayCreate.SizeExpression)).ConfigureAwait(false);
                        await (Output.WriteAsync(") - 1")).ConfigureAwait(false);
                    }
                    else
                    {
                        Output.Write(eAsArrayCreate.Size - 1);
                    }

                    await (Output.WriteAsync(')')).ConfigureAwait(false);

                    if (typeRef.ArrayElementType != null)
                        await (OutputArrayPostfixAsync(typeRef.ArrayElementType)).ConfigureAwait(false);

                    await (Output.WriteAsync(" As ")).ConfigureAwait(false);
                    await (OutputTypeAsync(typeRef)).ConfigureAwait(false);
                }
                else
                    await (OutputTypeNamePairAsync(e.Type, e.Name)).ConfigureAwait(false);
            }
            else
                await (OutputTypeNamePairAsync(e.Type, e.Name)).ConfigureAwait(false);

            if (doInit && e.InitExpression != null)
            {
                await (Output.WriteAsync(" = ")).ConfigureAwait(false);
                await (GenerateExpressionAsync(e.InitExpression)).ConfigureAwait(false);
            }

            await (Output.WriteLineAsync()).ConfigureAwait(false);
        }

        protected override async Task GeneratePropertyReferenceExpressionAsync(CodePropertyReferenceExpression e)
        {
            if (e.TargetObject != null)
            {
                await (GenerateExpressionAsync(e.TargetObject)).ConfigureAwait(false);
                await (Output.WriteAsync('.')).ConfigureAwait(false);
                await (Output.WriteAsync(e.PropertyName)).ConfigureAwait(false);
            }
            else
            {
                await (Output.WriteAsync('.')).ConfigureAwait(false);
                await (OutputIdentifierAsync(e.PropertyName)).ConfigureAwait(false);
            }
        }

        protected override async Task GenerateTypeOfExpressionAsync(CodeTypeOfExpression e)
        {
            await (Output.WriteAsync("GetType(")).ConfigureAwait(false);
            await (Output.WriteAsync(GetTypeOutput(e.Type))).ConfigureAwait(false);
            await (Output.WriteAsync(')')).ConfigureAwait(false);
        }

        protected override async Task ContinueOnNewLineAsync(string st, bool newLineContinuation = true)
        {
            await (Output.WriteAsync(st)).ConfigureAwait(false);
            await (Output.WriteLineAsync(newLineContinuation ? " _" : "")).ConfigureAwait(false);
        }

        private async Task GenerateVBStatementsAsync(CodeStatementCollection stms)
        {
            _statementDepth++;
            try
            {
                await (GenerateStatementsAsync(stms)).ConfigureAwait(false);
            }
            finally
            {
                _statementDepth--;
            }
        }
    }
}
